"use strict";
/**
 * Copyright (c) Hathor Labs and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const bitcore_lib_1 = require("bitcore-lib");
const buffer_1 = require("../utils/buffer");
const helpers_1 = __importDefault(require("../utils/helpers"));
const input_1 = __importDefault(require("./input"));
const output_1 = __importDefault(require("./output"));
const transaction_1 = __importDefault(require("./transaction"));
const errors_1 = require("../errors");
const buffer_2 = __importDefault(require("buffer"));
const lodash_1 = require("lodash");
class CreateTokenTransaction extends transaction_1.default {
    constructor(name, symbol, inputs, outputs, options = {}) {
        const defaultOptions = {
            weight: 0,
            nonce: 0,
            timestamp: null,
            parents: [],
            tokens: [],
            hash: null,
        };
        const newOptions = Object.assign(defaultOptions, options);
        super(inputs, outputs, newOptions);
        this.version = constants_1.CREATE_TOKEN_TX_VERSION;
        this.name = name;
        this.symbol = symbol;
    }
    /**
     * Return transaction data to sign in inputs
     *
     * @return {Buffer}
     * @memberof Transaction
     * @inner
     */
    getDataToSign() {
        if (this._dataToSignCache !== null) {
            return this._dataToSignCache;
        }
        let arr = [];
        this.serializeFundsFields(arr, false);
        this._dataToSignCache = bitcore_lib_1.util.buffer.concat(arr);
        return this._dataToSignCache;
    }
    /**
     * Serialize tx to bytes
     *
     * @return {Buffer}
     * @memberof Transaction
     * @inner
     */
    toBytes() {
        let arr = [];
        // Serialize first the funds part
        //
        this.serializeFundsFields(arr, true);
        // Graph fields
        this.serializeGraphFields(arr);
        // Nonce
        this.serializeNonce(arr);
        return bitcore_lib_1.util.buffer.concat(arr);
    }
    /**
     * Serialize funds fields
     * version, len inputs, len outputs, inputs, outputs and token info
     *
     * @param {Buffer[]} array Array of buffer to push the serialized fields
     * @param {boolean} addInputData If should add input data when serializing it
     *
     * @memberof Transaction
     * @inner
     */
    serializeFundsFields(array, addInputData) {
        // Tx version
        array.push(helpers_1.default.intToBytes(this.version, 2));
        // Funds len and fields
        this.serializeFundsFieldsLen(array);
        this.serializeInputsOutputs(array, addInputData);
        // Create token tx need to add extra information
        this.serializeTokenInfo(array);
    }
    /**
     * Serialize create token tx info to bytes
     *
     * @return {Array} array of bytes
     * @memberof Transaction
     * @inner
     */
    serializeTokenInfo(array) {
        if (!(this.name) || !(this.symbol)) {
            throw new errors_1.CreateTokenTxInvalid('Token name and symbol are required when creating a new token');
        }
        if (this.name.length > constants_1.MAX_TOKEN_NAME_SIZE) {
            throw new errors_1.CreateTokenTxInvalid(`Token name size is ${this.name.length} but maximum size is ${constants_1.MAX_TOKEN_NAME_SIZE}`);
        }
        if (this.symbol.length > constants_1.MAX_TOKEN_SYMBOL_SIZE) {
            throw new errors_1.CreateTokenTxInvalid(`Token symbol size is ${this.symbol.length} but maximum size is ${constants_1.MAX_TOKEN_SYMBOL_SIZE}`);
        }
        const nameBytes = buffer_2.default.Buffer.from(this.name, 'utf8');
        const symbolBytes = buffer_2.default.Buffer.from(this.symbol, 'utf8');
        // Token info version
        array.push(helpers_1.default.intToBytes(constants_1.TOKEN_INFO_VERSION, 1));
        // Token name size
        array.push(helpers_1.default.intToBytes(nameBytes.length, 1));
        // Token name
        array.push(nameBytes);
        // Token symbol size
        array.push(helpers_1.default.intToBytes(symbolBytes.length, 1));
        // Token symbol
        array.push(symbolBytes);
    }
    getTokenInfoFromBytes(buf) {
        let tokenInfoVersion, lenName, lenSymbol, bufName, bufSymbol;
        [tokenInfoVersion, buf] = buffer_1.unpackToInt(1, false, buf);
        if (tokenInfoVersion !== constants_1.TOKEN_INFO_VERSION) {
            throw new errors_1.CreateTokenTxInvalid(`Unknown token info version: ${tokenInfoVersion}`);
        }
        [lenName, buf] = buffer_1.unpackToInt(1, false, buf);
        if (lenName > constants_1.MAX_TOKEN_NAME_SIZE) {
            throw new errors_1.CreateTokenTxInvalid(`Token name size is ${lenName} but maximum size is ${constants_1.MAX_TOKEN_NAME_SIZE}`);
        }
        [bufName, buf] = buffer_1.unpackLen(lenName, buf);
        this.name = bufName.toString('utf-8');
        [lenSymbol, buf] = buffer_1.unpackToInt(1, false, buf);
        if (lenSymbol > constants_1.MAX_TOKEN_SYMBOL_SIZE) {
            throw new errors_1.CreateTokenTxInvalid(`Token symbol size is ${lenSymbol} but maximum size is ${constants_1.MAX_TOKEN_SYMBOL_SIZE}`);
        }
        [bufSymbol, buf] = buffer_1.unpackLen(lenSymbol, buf);
        this.symbol = bufSymbol.toString('utf-8');
        return buf;
    }
    /**
     * Gets funds fields (version, inputs, outputs) from bytes
     * and saves them in `this`
     *
     * @param {Buffer} buf Buffer with bytes to get fields
     * @param {Network} network Network to get output addresses first byte
     *
     * @return {Buffer} Rest of buffer after getting the fields
     * @memberof CreateTokenTransaction
     * @inner
     */
    getFundsFieldsFromBytes(buf, network) {
        // Tx version
        [this.version, buf] = buffer_1.unpackToInt(2, false, buf);
        let lenInputs, lenOutputs;
        // Len inputs
        [lenInputs, buf] = buffer_1.unpackToInt(1, false, buf);
        // Len outputs
        [lenOutputs, buf] = buffer_1.unpackToInt(1, false, buf);
        // Inputs array
        for (let i = 0; i < lenInputs; i++) {
            let input;
            [input, buf] = input_1.default.createFromBytes(buf);
            this.inputs.push(input);
        }
        // Outputs array
        for (let i = 0; i < lenOutputs; i++) {
            let output;
            [output, buf] = output_1.default.createFromBytes(buf, network);
            this.outputs.push(output);
        }
        return buf;
    }
    /**
     * Create transaction object from bytes
     *
     * @param {Buffer} buf Buffer with bytes to get transaction fields
     * @param {Network} network Network to get output addresses first byte
     *
     * @return {CreateTokenTransaction} Transaction object
     * @memberof CreateTokenTransaction
     * @static
     * @inner
     */
    static createFromBytes(buf, network) {
        const tx = new CreateTokenTransaction('', '', [], []);
        // Cloning buffer so we don't mutate anything sent by the user
        // as soon as it's available natively we should use an immutable buffer
        let txBuffer = lodash_1.clone(buf);
        txBuffer = tx.getFundsFieldsFromBytes(txBuffer, network);
        txBuffer = tx.getTokenInfoFromBytes(txBuffer);
        tx.getGraphFieldsFromBytes(txBuffer);
        tx.updateHash();
        return tx;
    }
}
exports.default = CreateTokenTransaction;
//# sourceMappingURL=create_token_transaction.js.map