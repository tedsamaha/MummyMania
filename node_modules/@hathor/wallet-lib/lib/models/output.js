"use strict";
/**
 * Copyright (c) Hathor Labs and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const errors_1 = require("../errors");
const helpers_1 = __importDefault(require("../utils/helpers"));
const buffer_1 = require("../utils/buffer");
const scripts_1 = require("../utils/scripts");
const lodash_1 = __importDefault(require("lodash"));
class Output {
    constructor(value, script, options = {}) {
        const defaultOptions = {
            tokenData: 0,
        };
        const newOptions = Object.assign(defaultOptions, options);
        const { tokenData } = newOptions;
        if (!value) {
            throw new errors_1.OutputValueError('Value must be a positive number.');
        }
        if (!script) {
            throw Error('You must provide a script.');
        }
        this.value = value;
        this.script = script;
        this.tokenData = tokenData;
        this.decodedScript = null;
    }
    /**
     * Get the bytes from the output value
     * If value is above the maximum for 32 bits we get from 8 bytes, otherwise only 4 bytes
     *
     * @throws {OutputValueError} Will throw an error if output value is invalid
     *
     * @return {Buffer}
     *
     * @memberof Transaction
     * @inner
     */
    valueToBytes() {
        if (this.value <= 0) {
            throw new errors_1.OutputValueError('Output value must be positive');
        }
        if (this.value > constants_1.MAX_OUTPUT_VALUE) {
            throw new errors_1.OutputValueError(`Maximum value is ${helpers_1.default.prettyValue(constants_1.MAX_OUTPUT_VALUE)}`);
        }
        if (this.value > constants_1.MAX_OUTPUT_VALUE_32) {
            return helpers_1.default.signedIntToBytes(-this.value, 8);
        }
        else {
            return helpers_1.default.signedIntToBytes(this.value, 4);
        }
    }
    /*
     * Returns if output is authority
     *
     * @return {boolean} If it's an authority output or not
     *
     * @memberof Output
     * @inner
     */
    isAuthority() {
        return (this.tokenData & constants_1.TOKEN_AUTHORITY_MASK) > 0;
    }
    /*
     * Verifies if output is of mint
     *
     * @return {boolean} if output is mint
     *
     * @memberof Output
     * @inner
     */
    isMint() {
        return this.isAuthority() && ((this.value & constants_1.TOKEN_MINT_MASK) > 0);
    }
    /*
     * Verifies if output is of melt
     *
     * @return {boolean} if output is melt
     *
     * @memberof Output
     * @inner
     */
    isMelt() {
        return this.isAuthority() && ((this.value & constants_1.TOKEN_MELT_MASK) > 0);
    }
    /**
     * Get index of token list of the output.
     * It already subtracts 1 from the final result,
     * so if this returns 0, it's the first token, i.e.
     * tokenData = 1, then getTokenIndex = 0.
     * For HTR output (tokenData = 0) it will return -1.
     *
     * @return {number} Index of the token of this output
     *
     * @memberof Output
     * @inner
     */
    getTokenIndex() {
        return (this.tokenData & constants_1.TOKEN_INDEX_MASK) - 1;
    }
    /**
     * Serialize an output to bytes
     *
     * @return {Buffer[]}
     * @memberof Output
     * @inner
     */
    serialize() {
        const arr = [];
        arr.push(this.valueToBytes());
        // Token data
        arr.push(helpers_1.default.intToBytes(this.tokenData, 1));
        arr.push(helpers_1.default.intToBytes(this.script.length, 2));
        arr.push(this.script);
        return arr;
    }
    parseScript(network) {
        // This method will work only for P2PKH scripts for now
        // The whole lib works only for this type of output script
        // We should do something similar to what we have in the full node with
        // Scripts regex verification match in the future
        // It's still unsure how expensive it is to throw an exception in JavaScript. Some languages are really
        // inefficient when it comes to exceptions while others are totally efficient. If it is efficient,
        // we can keep throwing the error. Otherwise, we should just return null
        // because this method will be used together with others when we are trying to parse a given script.
        try {
            const parsedScript = scripts_1.parseP2PKH(this.script, network);
            this.decodedScript = parsedScript;
            return parsedScript;
        }
        catch (error) {
            if (error instanceof errors_1.ParseError) {
                // We don't know how to parse this script
                return null;
            }
            else {
                throw error;
            }
        }
    }
    /**
     * Create output object from bytes
     *
     * @param {Buffer} buf Buffer with bytes to get output fields
     * @param {Network} network Network to get output addresses first byte
     *
     * @return {[Output, Buffer]} Created output and rest of buffer bytes
     * @memberof Output
     * @static
     * @inner
     */
    static createFromBytes(buf, network) {
        // Cloning buffer so we don't mutate anything sent by the user
        let outputBuffer = lodash_1.default.clone(buf);
        let value, tokenData, scriptLen, script;
        // Value
        [value, outputBuffer] = buffer_1.bytesToOutputValue(outputBuffer);
        // Token data
        [tokenData, outputBuffer] = buffer_1.unpackToInt(1, false, outputBuffer);
        // Script
        [scriptLen, outputBuffer] = buffer_1.unpackToInt(2, false, outputBuffer);
        [script, outputBuffer] = buffer_1.unpackLen(scriptLen, outputBuffer);
        const output = new Output(value, script, { tokenData });
        output.parseScript(network);
        return [output, outputBuffer];
    }
}
exports.default = Output;
//# sourceMappingURL=output.js.map