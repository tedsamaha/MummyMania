"use strict";
/**
 * Copyright (c) Hathor Labs and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const bitcore_lib_1 = require("bitcore-lib");
const buffer_1 = require("../utils/buffer");
const helpers_1 = __importDefault(require("../utils/helpers"));
const input_1 = __importDefault(require("./input"));
const output_1 = __importDefault(require("./output"));
const errors_1 = require("../errors");
const buffer_2 = __importDefault(require("buffer"));
const lodash_1 = require("lodash");
const crypto_1 = __importDefault(require("crypto"));
var txType;
(function (txType) {
    txType["BLOCK"] = "Block";
    txType["TRANSACTION"] = "Transaction";
    txType["CREATE_TOKEN_TRANSACTION"] = "Create Token Transaction";
    txType["MERGED_MINING_BLOCK"] = "Merged Mining Block";
})(txType || (txType = {}));
class Transaction {
    constructor(inputs, outputs, options = {}) {
        const defaultOptions = {
            version: constants_1.DEFAULT_TX_VERSION,
            weight: 0,
            nonce: 0,
            timestamp: null,
            parents: [],
            tokens: [],
            hash: null,
        };
        const newOptions = Object.assign(defaultOptions, options);
        const { version, weight, nonce, timestamp, parents, tokens, hash } = newOptions;
        this.inputs = inputs;
        this.outputs = outputs;
        this.version = version;
        this.weight = weight;
        this.nonce = nonce;
        this.timestamp = timestamp;
        this.parents = parents;
        this.tokens = tokens;
        this.hash = hash;
        // All inputs sign the same data, so we cache it in the first getDataToSign method call
        this._dataToSignCache = null;
    }
    /**
     * Returns a string with the short version of the tx hash
     * Returns {first12Chars}...{last12Chars}
     *
     * @return {string}
     * @memberof Transaction
     * @inner
     *
     */
    getShortHash() {
        return this.hash === null ? '' : `${this.hash.substring(0, 12)}...${this.hash.substring(52, 64)}`;
    }
    /**
     * Return transaction data to sign in inputs
     *
     * @return {Buffer}
     * @memberof Transaction
     * @inner
     */
    getDataToSign() {
        if (this._dataToSignCache !== null) {
            return this._dataToSignCache;
        }
        let arr = [];
        this.serializeFundsFields(arr, false);
        this._dataToSignCache = bitcore_lib_1.util.buffer.concat(arr);
        return this._dataToSignCache;
    }
    /**
     * Serialize funds fields
     * version, len tokens, len inputs, len outputs, tokens array, inputs and outputs
     *
     * @param {Buffer[]} array Array of buffer to push the serialized fields
     * @param {boolean} addInputData If should add input data when serializing it
     *
     * @memberof Transaction
     * @inner
     */
    serializeFundsFields(array, addInputData) {
        // Tx version
        array.push(helpers_1.default.intToBytes(this.version, 2));
        // Len tokens
        array.push(helpers_1.default.intToBytes(this.tokens.length, 1));
        // Len of inputs and outputs
        this.serializeFundsFieldsLen(array);
        // Tokens array
        this.serializeTokensArray(array);
        // Inputs and outputs
        this.serializeInputsOutputs(array, addInputData);
    }
    /**
     * Add to buffer array the serialization of the tokens array
     *
     * @memberof Transaction
     * @inner
     */
    serializeTokensArray(array) {
        // Tokens data
        for (const token of this.tokens) {
            array.push(buffer_1.hexToBuffer(token));
        }
    }
    /**
     * Add to buffer array the serialization of funds fields len (len of inputs and outputs)
     *
     * @memberof Transaction
     * @inner
     */
    serializeFundsFieldsLen(array) {
        // Len inputs
        array.push(helpers_1.default.intToBytes(this.inputs.length, 1));
        // Len outputs
        array.push(helpers_1.default.intToBytes(this.outputs.length, 1));
    }
    /**
     * Add to buffer array the serialization of funds fields (inputs and outputs)
     *
     * @memberof Transaction
     * @inner
     */
    serializeInputsOutputs(array, addInputData) {
        for (const inputTx of this.inputs) {
            array.push(...inputTx.serialize(addInputData));
        }
        for (const outputTx of this.outputs) {
            array.push(...outputTx.serialize());
        }
    }
    /**
     * Add to buffer array the serialization of graph fields and other serialization fields (weight, timestamp, parents and nonce)
     *
     * @memberof Transaction
     * @inner
     */
    serializeGraphFields(array) {
        // Now serialize the graph part
        //
        // Weight is a float with 8 bytes
        array.push(helpers_1.default.floatToBytes(this.weight, 8));
        // Timestamp
        array.push(helpers_1.default.intToBytes(this.timestamp, 4));
        if (this.parents) {
            array.push(helpers_1.default.intToBytes(this.parents.length, 1));
            for (const parent of this.parents) {
                array.push(buffer_1.hexToBuffer(parent));
            }
        }
        else {
            // Len parents (parents will be calculated in the backend)
            array.push(helpers_1.default.intToBytes(0, 1));
        }
    }
    /**
     * Serializes nonce
     *
     * @param {Buffer[]} array Array of buffer to push serialized nonce
     *
     * @memberof Transaction
     * @inner
     */
    serializeNonce(array) {
        // Add nonce in the end
        array.push(helpers_1.default.intToBytes(this.nonce, 4));
    }
    /*
     * Execute hash of the data to sign
     *
     * @return {Buffer} data to sign hashed
     *
     * @memberof Transaction
     * @inner
     */
    getDataToSignHash() {
        const dataToSign = this.getDataToSign();
        const hashbuf = bitcore_lib_1.crypto.Hash.sha256sha256(dataToSign);
        return new bitcore_lib_1.encoding.BufferReader(hashbuf).readReverse();
    }
    /**
     * Calculate the minimum tx weight
     *
     * @throws {ConstantNotSet} If the weight constants are not set yet
     *
     * @return {number} Minimum weight calculated (float)
     * @memberof Transaction
     * @inner
     */
    calculateWeight() {
        let txSize = this.toBytes().length;
        // If parents are not in txData, we need to consider them here
        if (!this.parents || !this.parents.length || this.parents.length === 0) {
            // Parents are always two and have 32 bytes each
            txSize += 64;
        }
        let sumOutputs = this.getOutputsSum();
        // Preventing division by 0 when handling authority methods that have no outputs
        sumOutputs = Math.max(1, sumOutputs);
        // We need to take into consideration the decimal places because it is inside the amount.
        // For instance, if one wants to transfer 20 HTRs, the amount will be 2000.
        const amount = sumOutputs / (Math.pow(10, constants_1.DECIMAL_PLACES));
        let weight = (constants_1.TX_WEIGHT_CONSTANTS.txWeightCoefficient * Math.log2(txSize) + 4 / (1 + constants_1.TX_WEIGHT_CONSTANTS.txMinWeightK / amount) + 4);
        // Make sure the calculated weight is at least the minimum
        weight = Math.max(weight, constants_1.TX_WEIGHT_CONSTANTS.txMinWeight);
        // FIXME precision difference between backend and frontend (weight (17.76246721531992) is smaller than the minimum weight (17.762467215319923))
        // Even though it must be fixed, there is no practical effect when mining the transaction
        return weight + 1e-6;
    }
    /**
     * Calculate the sum of outputs. Authority outputs are ignored.
     *
     * @return {number} Sum of outputs
     * @memberof Transaction
     * @inner
     */
    getOutputsSum() {
        let sumOutputs = 0;
        for (const output of this.outputs) {
            if (output.isAuthority()) {
                continue;
            }
            sumOutputs += output.value;
        }
        return sumOutputs;
    }
    /**
     * Serialize tx to bytes
     *
     * @return {Buffer}
     * @memberof Transaction
     * @inner
     */
    toBytes() {
        let arr = [];
        // Serialize first the funds part
        //
        this.serializeFundsFields(arr, true);
        // Weight, timestamp, parents
        this.serializeGraphFields(arr);
        // Nonce
        this.serializeNonce(arr);
        return bitcore_lib_1.util.buffer.concat(arr);
    }
    /**
     * Validate transaction information.
     * For now, we only verify the maximum number of inputs and outputs.
     *
     * @throws {MaximumNumberInputsError} If the tx has more inputs than the maximum allowed
     * @throws {MaximumNumberOutputsError} If the tx has more outputs than the maximum allowed
     *
     * @memberof Transaction
     * @inner
     */
    validate() {
        if (this.inputs.length > constants_1.MAX_INPUTS) {
            throw new errors_1.MaximumNumberInputsError(`Transaction has ${this.inputs.length} inputs and can have at most ${constants_1.MAX_INPUTS}.`);
        }
        if (this.outputs.length > constants_1.MAX_OUTPUTS) {
            throw new errors_1.MaximumNumberOutputsError(`Transaction has ${this.outputs.length} outputs and can have at most ${constants_1.MAX_OUTPUTS}.`);
        }
    }
    /**
     * Get tx data and return it in hexadecimal
     *
     * @return {String} Hexadecimal of a serialized tx
     * @memberof Transaction
     * @inner
     */
    toHex() {
        const txBytes = this.toBytes();
        return bitcore_lib_1.util.buffer.bufferToHex(txBytes);
    }
    /**
     * Get object type (Transaction or Block)
     *
     * @return {string} Type of the object
     *
     * @memberof Transaction
     * @inner
     */
    getType() {
        if (this.isBlock()) {
            if (this.version === constants_1.BLOCK_VERSION) {
                return txType.BLOCK;
            }
            else if (this.version === constants_1.MERGED_MINED_BLOCK_VERSION) {
                return txType.MERGED_MINING_BLOCK;
            }
        }
        else {
            if (this.version === constants_1.DEFAULT_TX_VERSION) {
                return txType.TRANSACTION;
            }
            else if (this.version === constants_1.CREATE_TOKEN_TX_VERSION) {
                return txType.CREATE_TOKEN_TRANSACTION;
            }
        }
        // If there is no match
        return 'Unknown';
    }
    /**
     * Check if object is a block or a transaction
     *
     * @return {boolean} true if object is a block, false otherwise
     *
     * @memberof Transaction
     * @inner
     */
    isBlock() {
        return this.version === constants_1.BLOCK_VERSION || this.version === constants_1.MERGED_MINED_BLOCK_VERSION;
    }
    /**
     * Set tx timestamp and weight
     *
     * @memberof Transaction
     * @inner
     */
    prepareToSend() {
        this.updateTimestamp();
        this.weight = this.calculateWeight();
    }
    /**
     * Update transaction timestamp
     * If timestamp parameter is not sent, we use now
     *
     * @memberof Transaction
     * @inner
     */
    updateTimestamp(timestamp = null) {
        let timestampToSet = timestamp;
        if (!timestamp) {
            timestampToSet = Math.floor(Date.now() / 1000);
        }
        this.timestamp = timestampToSet;
    }
    /**
     * Gets funds fields (version, tokens, inputs, outputs) from bytes
     * and saves them in `this`
     *
     * @param {Buffer} buf Buffer with bytes to get fields
     * @param {Network} network Network to get output addresses first byte
     *
     * @return {Buffer} Rest of buffer after getting the fields
     * @memberof Transaction
     * @inner
     */
    getFundsFieldsFromBytes(buf, network) {
        // Tx version
        [this.version, buf] = buffer_1.unpackToInt(2, false, buf);
        let lenTokens, lenInputs, lenOutputs;
        // Len tokens
        [lenTokens, buf] = buffer_1.unpackToInt(1, false, buf);
        // Len inputs
        [lenInputs, buf] = buffer_1.unpackToInt(1, false, buf);
        // Len outputs
        [lenOutputs, buf] = buffer_1.unpackToInt(1, false, buf);
        // Tokens array
        for (let i = 0; i < lenTokens; i++) {
            let tokenUid;
            [tokenUid, buf] = buffer_1.unpackToHex(constants_1.TX_HASH_SIZE_BYTES, buf);
            this.tokens.push(tokenUid);
        }
        // Inputs array
        for (let i = 0; i < lenInputs; i++) {
            let input;
            [input, buf] = input_1.default.createFromBytes(buf);
            this.inputs.push(input);
        }
        // Outputs array
        for (let i = 0; i < lenOutputs; i++) {
            let output;
            [output, buf] = output_1.default.createFromBytes(buf, network);
            this.outputs.push(output);
        }
        return buf;
    }
    /**
     * Gets graph fields (weight, timestamp, parents, nonce) from bytes
     * and saves them in `this`
     *
     * @param {Buffer} buf Buffer with bytes to get fields
     *
     * @return {Buffer} Rest of buffer after getting the fields
     * @memberof Transaction
     * @inner
     */
    getGraphFieldsFromBytes(buf) {
        // Weight
        [this.weight, buf] = buffer_1.unpackToFloat(buf);
        // Timestamp
        [this.timestamp, buf] = buffer_1.unpackToInt(4, false, buf);
        // Parents
        let parentsLen;
        [parentsLen, buf] = buffer_1.unpackToInt(1, false, buf);
        for (let i = 0; i < parentsLen; i++) {
            let p;
            [p, buf] = buffer_1.unpackToHex(constants_1.TX_HASH_SIZE_BYTES, buf);
            this.parents.push(p);
        }
        // Nonce
        [this.nonce, buf] = buffer_1.unpackToInt(4, false, buf);
        return buf;
    }
    /**
     * Create transaction object from bytes
     *
     * @param {Buffer} buf Buffer with bytes to get transaction fields
     * @param {Network} network Network to get output addresses first byte
     *
     * @return {Transaction} Transaction object
     * @memberof Transaction
     * @static
     * @inner
     */
    static createFromBytes(buf, network) {
        const tx = new Transaction([], []);
        // Cloning buffer so we don't mutate anything sent by the user
        // as soon as it's available natively we should use an immutable buffer
        let txBuffer = lodash_1.clone(buf);
        txBuffer = tx.getFundsFieldsFromBytes(txBuffer, network);
        tx.getGraphFieldsFromBytes(txBuffer);
        tx.updateHash();
        return tx;
    }
    /**
     * Calculate first part of transaction hash
     *
     * @return {object} Sha256 hash object of part1
     *
     * @memberof Transaction
     * @inner
     */
    calculateHashPart1() {
        const arrFunds = [];
        this.serializeFundsFields(arrFunds, true);
        const fundsHash = crypto_1.default.createHash('sha256');
        fundsHash.update(buffer_2.default.Buffer.concat(arrFunds));
        const digestedFunds = fundsHash.digest();
        const arrGraph = [];
        this.serializeGraphFields(arrGraph);
        const graphHash = crypto_1.default.createHash('sha256');
        graphHash.update(buffer_2.default.Buffer.concat(arrGraph));
        const digestedGraph = graphHash.digest();
        const bufferPart1 = buffer_2.default.Buffer.concat([digestedFunds, digestedGraph]);
        const part1 = crypto_1.default.createHash('sha256');
        part1.update(bufferPart1);
        return part1;
    }
    /**
     * Calculate transaction hash from part1
     *
     * @return {Buffer} Transaction hash in bytes
     *
     * @memberof Transaction
     * @inner
     */
    calculateHashPart2(part1) {
        const arrNonce = [];
        this.serializeNonce(arrNonce);
        const bufferFill = buffer_2.default.Buffer.alloc(12);
        const fullNonceBytes = buffer_2.default.Buffer.concat([bufferFill, buffer_2.default.Buffer.concat(arrNonce)]);
        part1.update(fullNonceBytes);
        const part2 = crypto_1.default.createHash('sha256');
        part2.update(part1.digest());
        return part2.digest().reverse();
    }
    /**
     * Calculate transaction hash and return it
     *
     * @return {string} Transaction hash in hexadecimal
     *
     * @memberof Transaction
     * @inner
     */
    calculateHash() {
        const hashPart1 = this.calculateHashPart1();
        const hashPart2 = this.calculateHashPart2(hashPart1);
        return buffer_1.bufferToHex(hashPart2);
    }
    /**
     * Update transaction hash
     *
     * @memberof Transaction
     * @inner
     */
    updateHash() {
        this.hash = this.calculateHash();
    }
}
exports.default = Transaction;
//# sourceMappingURL=transaction.js.map