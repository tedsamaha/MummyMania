"use strict";
/**
 * Copyright (c) Hathor Labs and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const opcodes_1 = require("../opcodes");
const bitcore_lib_1 = require("bitcore-lib");
const helpers_1 = __importDefault(require("../utils/helpers"));
class P2PKH {
    constructor(address, options = {}) {
        const defaultOptions = {
            timelock: null,
        };
        const newOptions = Object.assign(defaultOptions, options);
        const { timelock } = newOptions;
        if (!address) {
            throw Error('You must provide an address.');
        }
        this.address = address;
        this.timelock = timelock;
    }
    /**
     * Create a P2PKH script
     *
     * @return {Buffer}
     * @memberof P2PKH
     * @inner
     */
    createScript() {
        const arr = [];
        const addressBytes = this.address.decode();
        const addressHash = addressBytes.slice(1, -4);
        if (this.timelock) {
            let timelockBytes = helpers_1.default.intToBytes(this.timelock, 4);
            helpers_1.default.pushDataToStack(arr, timelockBytes);
            arr.push(opcodes_1.OP_GREATERTHAN_TIMESTAMP);
        }
        arr.push(opcodes_1.OP_DUP);
        arr.push(opcodes_1.OP_HASH160);
        // addressHash has a fixed size of 20 bytes, so no need to push OP_PUSHDATA1
        arr.push(helpers_1.default.intToBytes(addressHash.length, 1));
        arr.push(addressHash);
        arr.push(opcodes_1.OP_EQUALVERIFY);
        arr.push(opcodes_1.OP_CHECKSIG);
        return bitcore_lib_1.util.buffer.concat(arr);
    }
}
exports.default = P2PKH;
//# sourceMappingURL=p2pkh.js.map