"use strict";
/**
 * Copyright (c) Hathor Labs and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("../utils/buffer");
const helpers_1 = __importDefault(require("../utils/helpers"));
const constants_1 = require("../constants");
const buffer_2 = require("../utils/buffer");
const lodash_1 = __importDefault(require("lodash"));
class Input {
    constructor(hash, index, options = {}) {
        const defaultOptions = {
            data: null
        };
        const newOptions = Object.assign(defaultOptions, options);
        const { data } = newOptions;
        if (!hash) {
            throw Error('You must provide a hash.');
        }
        if (isNaN(index)) {
            throw Error('You must provide an index.');
        }
        this.hash = hash;
        this.index = index;
        this.data = data;
    }
    /**
     * Serialize an input to bytes
     *
     * @param {boolean} addData If should add the input data to the serialization
     * The data is not used to sign/verify the transaction (see https://github.com/HathorNetwork/rfcs/blob/master/text/0015-anatomy-of-tx.md)
     * thus it's important to have this parameter and not add the data to serialization when getting the transaction data to sign
     *
     * @return {Buffer[]}
     * @memberof Input
     * @inner
     */
    serialize(addData = true) {
        const arr = [];
        arr.push(buffer_1.hexToBuffer(this.hash));
        arr.push(helpers_1.default.intToBytes(this.index, 1));
        if (this.data && addData) {
            arr.push(helpers_1.default.intToBytes(this.data.length, 2));
            arr.push(this.data);
        }
        else {
            arr.push(helpers_1.default.intToBytes(0, 2));
        }
        return arr;
    }
    setData(data) {
        this.data = data;
    }
    /**
     * Create input object from bytes
     *
     * @param {Buffer} buf Buffer with bytes to get input fields
     *
     * @return {[Input, Buffer]} Created input and rest of buffer bytes
     * @memberof Input
     * @static
     * @inner
     */
    static createFromBytes(buf) {
        // Cloning buffer so we don't mutate anything sent by the user
        let inputBuffer = lodash_1.default.clone(buf);
        let hash, index, dataLen, data;
        // Hash
        [hash, inputBuffer] = buffer_2.unpackToHex(constants_1.TX_HASH_SIZE_BYTES, inputBuffer);
        // Index
        [index, inputBuffer] = buffer_2.unpackToInt(1, false, inputBuffer);
        // Data
        [dataLen, inputBuffer] = buffer_2.unpackToInt(2, false, inputBuffer);
        if (dataLen) {
            [data, inputBuffer] = buffer_2.unpackLen(dataLen, inputBuffer);
        }
        const input = new Input(hash, index, { data });
        return [input, inputBuffer];
    }
}
exports.default = Input;
//# sourceMappingURL=input.js.map