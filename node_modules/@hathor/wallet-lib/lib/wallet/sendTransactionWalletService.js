"use strict";
/**
 * Copyright (c) Hathor Labs and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const walletApi_1 = __importDefault(require("./api/walletApi"));
const mineTransaction_1 = __importDefault(require("./mineTransaction"));
const p2pkh_1 = __importDefault(require("../models/p2pkh"));
const transaction_1 = __importDefault(require("../models/transaction"));
const output_1 = __importDefault(require("../models/output"));
const input_1 = __importDefault(require("../models/input"));
const address_1 = __importDefault(require("../models/address"));
const constants_1 = require("../constants");
const lodash_1 = require("lodash");
const errors_1 = require("../errors");
class SendTransactionWalletService extends events_1.EventEmitter {
    constructor(wallet, options = {}) {
        super();
        const newOptions = Object.assign({
            outputs: [],
            inputs: [],
            changeAddress: null,
            transaction: null,
        }, options);
        this.wallet = wallet;
        this.outputs = newOptions.outputs;
        this.inputs = newOptions.inputs;
        this.changeAddress = newOptions.changeAddress;
        this.transaction = newOptions.transaction;
        this.mineTransaction = null;
    }
    /**
     * Prepare transaction data to send
     * Get utxos from wallet service, creates change outpus and returns a Transaction object
     *
     * @memberof SendTransactionWalletService
     * @inner
     */
    prepareTx() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.outputs.length === 0) {
                throw new errors_1.WalletError('Can\'t prepare transactions with no outputs.');
            }
            this.emit('prepare-tx-start');
            // We get the full outputs amount for each token
            // This is useful for (i) getting the utxos for each one
            // in case it's not sent and (ii) create the token array of the tx
            const tokenAmountMap = {};
            for (const output of this.outputs) {
                if (output.token in tokenAmountMap) {
                    tokenAmountMap[output.token] += output.value;
                }
                else {
                    tokenAmountMap[output.token] = output.value;
                }
            }
            // We need this array to get the addressPath for each input used and be able to sign the input data
            let utxosAddressPath;
            if (this.inputs.length === 0) {
                // Need to get utxos
                // We already know the full amount for each token
                // Now we can get the utxos and (if needed) change amount for each token
                utxosAddressPath = yield this.selectUtxosToUse(tokenAmountMap);
            }
            else {
                // If the user selected the inputs, we must validate that
                // all utxos are valid and the sum is enought to fill the outputs
                utxosAddressPath = yield this.validateUtxos(tokenAmountMap);
            }
            // Create tokens array, in order to calculate each output tokenData
            // if HTR appears in the array, we must remove it
            // because we don't add HTR to the transaction tokens array
            const tokens = Object.keys(tokenAmountMap);
            const htrIndex = tokens.indexOf(constants_1.HATHOR_TOKEN_CONFIG.uid);
            if (htrIndex > -1) {
                tokens.splice(htrIndex, 1);
            }
            // Transform input data in Input model object
            const inputsObj = [];
            for (const i of this.inputs) {
                inputsObj.push(this.inputDataToModel(i));
            }
            // Transform output data in Output model object
            const outputsObj = [];
            for (const o of this.outputs) {
                outputsObj.push(this.outputDataToModel(o, tokens));
            }
            // Create the transaction object, add weight and timestamp
            this.transaction = new transaction_1.default(inputsObj, outputsObj);
            this.transaction.tokens = tokens;
            this.emit('prepare-tx-end', this.transaction);
            return { transaction: this.transaction, utxosAddressPath };
        });
    }
    /**
     * Map input data to an input object
     *
     * @memberof SendTransactionWalletService
     * @inner
     */
    inputDataToModel(input) {
        return new input_1.default(input.txId, input.index);
    }
    /**
     * Map output data to an output object
     *
     * @memberof SendTransactionWalletService
     * @inner
     */
    outputDataToModel(output, tokens) {
        const address = new address_1.default(output.address, { network: this.wallet.network });
        if (!address.isValid()) {
            throw new errors_1.SendTxError(`Address ${output.address} is not valid.`);
        }
        const tokenData = (tokens.indexOf(output.token) > -1) ? tokens.indexOf(output.token) + 1 : 0;
        const outputOptions = { tokenData };
        const p2pkh = new p2pkh_1.default(address, { timelock: output.timelock || null });
        const p2pkhScript = p2pkh.createScript();
        return new output_1.default(output.value, p2pkhScript, outputOptions);
    }
    /**
     * Check if the utxos selected are valid and the sum is enough to
     * fill the outputs. If needed, create change output
     *
     * @memberof SendTransactionWalletService
     * @inner
     */
    validateUtxos(tokenAmountMap) {
        return __awaiter(this, void 0, void 0, function* () {
            const amountInputMap = {};
            const utxosAddressPath = [];
            for (const input of this.inputs) {
                const utxo = yield this.wallet.getUtxoFromId(input.txId, input.index);
                if (utxo === null) {
                    throw new errors_1.UtxoError(`Invalid input selection. Input ${input.txId} at index ${input.index}.`);
                }
                if (!(utxo.tokenId in tokenAmountMap)) {
                    throw new errors_1.SendTxError(`Invalid input selection. Input ${input.txId} at index ${input.index} has token ${utxo.tokenId} that is not on the outputs.`);
                }
                utxosAddressPath.push(utxo.addressPath);
                if (utxo.tokenId in amountInputMap) {
                    amountInputMap[utxo.tokenId] += utxo.value;
                }
                else {
                    amountInputMap[utxo.tokenId] = utxo.value;
                }
            }
            for (const t in tokenAmountMap) {
                if (!(t in amountInputMap)) {
                    throw new errors_1.SendTxError(`Invalid input selection. Token ${t} is in the outputs but there are no inputs for it.`);
                }
                if (amountInputMap[t] < tokenAmountMap[t]) {
                    throw new errors_1.SendTxError(`Invalid input selection. Sum of inputs for token ${t} is smaller than the sum of outputs.`);
                }
                if (amountInputMap[t] > tokenAmountMap[t]) {
                    const changeAmount = amountInputMap[t] - tokenAmountMap[t];
                    const changeAddress = this.changeAddress || this.wallet.getCurrentAddress({ markAsUsed: true }).address;
                    this.outputs.push({ address: changeAddress, value: changeAmount, token: t });
                    // If we add a change output, then we must shuffle it
                    this.outputs = lodash_1.shuffle(this.outputs);
                }
            }
            return utxosAddressPath;
        });
    }
    /**
     * Select utxos to be used in the transaction
     * Get utxos from wallet service and creates change output if needed
     *
     * @memberof SendTransactionWalletService
     * @inner
     */
    selectUtxosToUse(tokenAmountMap) {
        return __awaiter(this, void 0, void 0, function* () {
            const utxosAddressPath = [];
            for (const token in tokenAmountMap) {
                const { utxos, changeAmount } = yield this.wallet.getUtxos({ tokenId: token, totalAmount: tokenAmountMap[token] });
                if (utxos.length === 0) {
                    throw new errors_1.UtxoError(`No utxos available to fill the request. Token: ${token} - Amount: ${tokenAmountMap[token]}.`);
                }
                for (const utxo of utxos) {
                    this.inputs.push({ txId: utxo.txId, index: utxo.index });
                    utxosAddressPath.push(utxo.addressPath);
                }
                if (changeAmount) {
                    const changeAddress = this.changeAddress || this.wallet.getCurrentAddress({ markAsUsed: true }).address;
                    this.outputs.push({ address: changeAddress, value: changeAmount, token });
                    // If we add a change output, then we must shuffle it
                    this.outputs = lodash_1.shuffle(this.outputs);
                }
            }
            return utxosAddressPath;
        });
    }
    /**
     * Signs the inputs of a transaction
     *
     * @memberof SendTransactionWalletService
     * @inner
     */
    signTx(utxosAddressPath) {
        if (this.transaction === null) {
            throw new errors_1.WalletError('Can\'t sign transaction if it\'s null.');
        }
        this.emit('sign-tx-start');
        const dataToSignHash = this.transaction.getDataToSignHash();
        for (const [idx, inputObj] of this.transaction.inputs.entries()) {
            const inputData = this.wallet.getInputData(dataToSignHash, utxosAddressPath[idx]);
            inputObj.setData(inputData);
        }
        // Now that the tx is completed with the data of the input
        // we can add the timestamp and calculate the weight
        this.transaction.prepareToSend();
        this.emit('sign-tx-end', this.transaction);
    }
    /**
     * Mine the transaction
     * Expects this.transaction to be prepared and signed
     * Emits MineTransaction events while the process is ongoing
     *
     * @memberof SendTransactionWalletService
     * @inner
     */
    mineTx(options = {}) {
        if (this.transaction === null) {
            throw new errors_1.WalletError('Can\'t mine transaction if it\'s null.');
        }
        const newOptions = Object.assign({
            startMiningTx: true,
            maxTxMiningRetries: 3,
        }, options);
        this.mineTransaction = new mineTransaction_1.default(this.transaction, { maxTxMiningRetries: newOptions.maxTxMiningRetries });
        this.mineTransaction.on('mining-started', () => {
            this.emit('mine-tx-started');
        });
        this.mineTransaction.on('estimation-updated', (data) => {
            this.emit('estimation-updated', data);
        });
        this.mineTransaction.on('job-submitted', (data) => {
            this.emit('job-submitted', data);
        });
        this.mineTransaction.on('job-done', (data) => {
            this.emit('job-done', data);
        });
        this.mineTransaction.on('error', (message) => {
            this.emit('send-error', message);
        });
        this.mineTransaction.on('unexpected-error', (message) => {
            this.emit('send-error', message);
        });
        this.mineTransaction.on('success', (data) => {
            this.emit('mine-tx-ended', data);
        });
        if (newOptions.startMiningTx) {
            this.mineTransaction.start();
        }
        return this.mineTransaction.promise;
    }
    /**
     * Create and send a tx proposal to wallet service
     * Expects this.transaction to be prepared, signed and mined
     *
     * @memberof SendTransactionWalletService
     * @inner
     */
    handleSendTxProposal() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.transaction === null) {
                throw new errors_1.WalletError('Can\'t push transaction if it\'s null.');
            }
            this.emit('send-tx-start', this.transaction);
            const txHex = this.transaction.toHex();
            try {
                const responseData = yield walletApi_1.default.createTxProposal(this.wallet, txHex);
                const txProposalId = responseData.txProposalId;
                const sendData = yield walletApi_1.default.updateTxProposal(this.wallet, txProposalId, txHex);
                this.transaction.updateHash();
                this.emit('send-tx-success', this.transaction);
                return this.transaction;
            }
            catch (err) {
                if (err instanceof errors_1.WalletRequestError) {
                    const errMessage = 'Error sending tx proposal.';
                    this.emit('send-error', errMessage);
                    throw errors_1.SendTxError(errMessage);
                }
                else {
                    throw err;
                }
            }
        });
    }
    /**
     * Run sendTransaction from mining, i.e. expects this.transaction to be prepared and signed
     * then it will mine and handle tx proposal
     *
     * 'until' parameter can be 'mine-tx', in order to only mine the transaction without propagating
     *
     * @memberof SendTransactionWalletService
     * @inner
     */
    runFromMining(until = null) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // This will await until mine tx is fully completed
                // mineTx method returns a promise that resolves when
                // mining succeeds or rejects when there is an error
                const mineData = yield this.mineTx();
                this.transaction.parents = mineData.parents;
                this.transaction.timestamp = mineData.timestamp;
                this.transaction.nonce = mineData.nonce;
                this.transaction.weight = mineData.weight;
                if (until === 'mine-tx') {
                    return this.transaction;
                }
                const tx = yield this.handleSendTxProposal();
                return tx;
            }
            catch (err) {
                if (err instanceof errors_1.WalletError) {
                    this.emit('send-error', err.message);
                }
                throw err;
            }
        });
    }
    /**
     * Run sendTransaction from preparing, i.e. prepare, sign, mine and send the tx
     *
     * 'until' parameter can be 'prepare-tx' (it will stop before signing the tx), 'sign-tx' (it will stop before mining the tx),
     * or 'mine-tx' (it will stop before send tx proposal, i.e. propagating the tx)
     *
     * @memberof SendTransactionWalletService
     * @inner
     */
    run(until = null) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const preparedData = yield this.prepareTx();
                if (until === 'prepare-tx') {
                    return this.transaction;
                }
                this.signTx(preparedData.utxosAddressPath);
                if (until === 'sign-tx') {
                    return this.transaction;
                }
                const tx = yield this.runFromMining(until);
                return tx;
            }
            catch (err) {
                if (err instanceof errors_1.WalletError) {
                    this.emit('send-error', err.message);
                }
                throw err;
            }
        });
    }
}
exports.default = SendTransactionWalletService;
//# sourceMappingURL=sendTransactionWalletService.js.map