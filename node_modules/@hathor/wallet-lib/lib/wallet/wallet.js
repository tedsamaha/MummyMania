"use strict";
/**
 * Copyright (c) Hathor Labs and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const constants_1 = require("../constants");
const bitcore_mnemonic_1 = __importDefault(require("bitcore-mnemonic"));
const bitcore_lib_1 = require("bitcore-lib");
const walletApi_1 = __importDefault(require("./api/walletApi"));
const wallet_1 = __importDefault(require("../utils/wallet"));
const helpers_1 = __importDefault(require("../utils/helpers"));
const transaction_1 = __importDefault(require("../utils/transaction"));
const tokens_1 = __importDefault(require("../utils/tokens"));
const p2pkh_1 = __importDefault(require("../models/p2pkh"));
const transaction_2 = __importDefault(require("../models/transaction"));
const create_token_transaction_1 = __importDefault(require("../models/create_token_transaction"));
const output_1 = __importDefault(require("../models/output"));
const input_1 = __importDefault(require("../models/input"));
const address_1 = __importDefault(require("../models/address"));
const network_1 = __importDefault(require("../network"));
const sendTransactionWalletService_1 = __importDefault(require("./sendTransactionWalletService"));
const bitcore_lib_2 = __importDefault(require("bitcore-lib"));
const errors_1 = require("../errors");
const errorMessages_1 = require("../errorMessages");
// Time in milliseconds berween each polling to check wallet status
// if it ended loading and became ready
const WALLET_STATUS_POLLING_INTERVAL = 3000;
var walletState;
(function (walletState) {
    walletState["NOT_STARTED"] = "Not started";
    walletState["LOADING"] = "Loading";
    walletState["READY"] = "Ready";
})(walletState || (walletState = {}));
class HathorWalletServiceWallet extends events_1.EventEmitter {
    constructor(seed, network, options = { passphrase: '' }) {
        super();
        const { passphrase } = options;
        if (!seed) {
            throw Error('You must explicitly provide the seed.');
        }
        this.state = walletState.NOT_STARTED;
        // It will throw InvalidWords error in case is not valid
        wallet_1.default.wordsValid(seed);
        this.seed = seed;
        this.passphrase = passphrase;
        // ID of wallet after created on wallet service
        this.walletId = null;
        this.isSendingTx = false;
        this.txProposalId = null;
        this.xpub = null;
        this.network = network;
        network_1.default.setNetwork(this.network.name);
        this.authToken = null;
        this.walletStatusInterval = null;
        // TODO When we integrate the real time events from the wallet service
        // we will need to have a trigger to update this array every new transaction
        // because the new tx might have used one of those addresses
        // so we just need to call await this.getNewAddresses(); on the new tx event
        this.newAddresses = [];
        this.indexToUse = -1;
        // TODO should we have a debug mode?
    }
    /**
     * Start wallet: load the wallet data, update state and start polling wallet status until it's ready
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.setState(walletState.LOADING);
            const xpub = wallet_1.default.getXPubKeyFromSeed(this.seed, { passphrase: this.passphrase, networkName: this.network.name });
            const xpubChangeDerivation = wallet_1.default.xpubDeriveChild(xpub, 0);
            const firstAddress = wallet_1.default.getAddressAtIndex(xpubChangeDerivation, 0, this.network.name);
            this.xpub = xpub;
            const handleCreate = (data) => __awaiter(this, void 0, void 0, function* () {
                this.walletId = data.walletId;
                if (data.status === 'creating') {
                    this.walletStatusInterval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                        yield this.startPollingStatus();
                    }), WALLET_STATUS_POLLING_INTERVAL);
                }
                else if (data.status === 'ready') {
                    yield this.onWalletReady();
                }
                else {
                    throw new errors_1.WalletRequestError(errorMessages_1.ErrorMessages.WALLET_STATUS_ERROR);
                }
            });
            const data = yield walletApi_1.default.createWallet(this, this.xpub, firstAddress);
            yield handleCreate(data.status);
        });
    }
    /**
     * Return wallet auth token
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getAuthToken() {
        return this.authToken;
    }
    /**
     * When the wallet starts, it might take some seconds for the wallet service to completely load all addresses
     * This method is responsible for polling the wallet status until it's ready
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    startPollingStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield walletApi_1.default.getWalletStatus(this);
            if (data.status.status === 'ready') {
                clearInterval(this.walletStatusInterval);
                yield this.onWalletReady();
            }
            else if (data.status.status !== 'creating') {
                // If it's still creating, then the setInterval must run again
                throw new errors_1.WalletRequestError('Error getting wallet status.');
            }
        });
    }
    /**
     * Check if wallet is ready and throw error if not ready
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    failIfWalletNotReady() {
        if (!this.isReady()) {
            throw new errors_1.WalletError('Wallet not ready');
        }
    }
    /**
     * Method executed when wallet is ready
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    onWalletReady() {
        return __awaiter(this, void 0, void 0, function* () {
            this.setState(walletState.READY);
            yield this.getNewAddresses();
        });
    }
    /**
     * Get all addresses of the wallet
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getAllAddresses() {
        return __asyncGenerator(this, arguments, function* getAllAddresses_1() {
            this.failIfWalletNotReady();
            const data = yield __await(walletApi_1.default.getAddresses(this));
            for (const address of data.addresses) {
                yield yield __await(address);
            }
        });
    }
    /**
     * Get the new addresses to be used by this wallet, i.e. the last GAP LIMIT unused addresses
     * Then it updates this.newAddresses and this.indexToUse that handle the addresses to use
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getNewAddresses() {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const data = yield walletApi_1.default.getNewAddresses(this);
            this.newAddresses = data.addresses;
            this.indexToUse = 0;
        });
    }
    /**
     * Get the balance of the wallet for a specific token
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getBalance(token = null) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const data = yield walletApi_1.default.getBalances(this, token);
            return data.balances;
        });
    }
    getTokens() {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const data = yield walletApi_1.default.getTokens(this);
            return data.tokens;
        });
    }
    /**
     * Get the history of the wallet for a specific token
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getTxHistory(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const data = yield walletApi_1.default.getHistory(this, options);
            return data.history;
        });
    }
    /**
     * Get utxo from tx id and index
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getUtxoFromId(txId, index) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield walletApi_1.default.getUtxos(this, { txId, index });
            const utxos = data.utxos;
            if (utxos.length === 0) {
                // No utxo for this txId/index or is not from the requested wallet
                return null;
            }
            else {
                if (utxos.length > 1) {
                    throw new errors_1.UtxoError(`Expected to receive only one utxo for txId ${txId} and index ${index} but received ${utxos.length}.`);
                }
                return utxos[0];
            }
        });
    }
    /**
     * Get utxos for filling a transaction
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getUtxos(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const newOptions = Object.assign({
                tokenId: constants_1.HATHOR_TOKEN_CONFIG.uid,
                authority: null,
                addresses: null,
                totalAmount: null,
                count: 1,
            }, options);
            if (!newOptions.authority && !newOptions.totalAmount) {
                throw new errors_1.UtxoError('We need the total amount of utxos if it\'s not an authority request.');
            }
            newOptions['ignoreLocked'] = true;
            const data = yield walletApi_1.default.getUtxos(this, newOptions);
            let changeAmount = 0;
            let utxos = [];
            if (data.utxos.length === 0) {
                // No utxos available for the requested filter
                utxos = data.utxos;
            }
            else if (newOptions.authority) {
                // Requests an authority utxo, then I return the count of requested authority utxos
                utxos = data.utxos.slice(0, newOptions.count);
            }
            else {
                // We got an array of utxos, then we must check if there is enough amount to fill the totalAmount
                // and slice the least possible utxos
                const ret = transaction_1.default.selectUtxos(data.utxos, newOptions.totalAmount);
                changeAmount = ret.changeAmount;
                utxos = ret.utxos;
            }
            return { utxos, changeAmount };
        });
    }
    /**
     * Signs a message using xpriv derivation path m/44'/280'/0'
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    signMessage(timestamp) {
        const xpriv = wallet_1.default.getXPrivKeyFromSeed(this.seed, { passphrase: this.passphrase, networkName: this.network.name });
        const derivedPrivKey = wallet_1.default.deriveXpriv(xpriv, '0\'');
        const address = derivedPrivKey.publicKey.toAddress(this.network.getNetwork()).toString();
        const message = new bitcore_lib_2.default.Message(String(timestamp).concat(this.walletId).concat(address));
        return message.sign(derivedPrivKey.privateKey);
    }
    /**
     * Validate that the wallet auth token is valid
     * If it's not valid, requests a new one and update
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    validateAndRenewAuthToken() {
        return __awaiter(this, void 0, void 0, function* () {
            const now = new Date();
            const timestampNow = Math.floor(now.getTime() / 1000);
            const validateJWTExpireDate = (token) => {
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace('-', '+').replace('_', '/');
                const decodedData = JSON.parse(Buffer.from(base64, 'base64').toString('binary'));
                // If the token will expire in the next 60 seconds (or has already expired)
                const delta = 60;
                if (timestampNow + delta > decodedData.exp) {
                    return false;
                }
                return true;
            };
            if (!this.authToken || !validateJWTExpireDate(this.authToken)) {
                const sign = this.signMessage(timestampNow);
                const data = yield walletApi_1.default.createAuthToken(this, timestampNow, this.xpub, sign);
                this.authToken = data.token;
            }
        });
    }
    /**
     * Creates and send a transaction from an array of inputs and outputs
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    sendManyOutputsTransaction(outputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const newOptions = Object.assign({
                inputs: [],
                changeAddress: null
            }, options);
            const { inputs, changeAddress } = newOptions;
            const sendTransaction = new sendTransactionWalletService_1.default(this, { outputs, inputs, changeAddress });
            return sendTransaction.run();
        });
    }
    /**
     * Creates and send a simple transaction with one output
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    sendTransaction(address, value, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const newOptions = Object.assign({
                token: '00',
                changeAddress: null
            }, options);
            const { token, changeAddress } = newOptions;
            const outputs = [{ address, value, token }];
            return this.sendManyOutputsTransaction(outputs, { inputs: [], changeAddress });
        });
    }
    /**
     * Calculate input data from dataToSign and addressPath
     * Get the private key corresponding to the addressPath,
     * calculate the signature and add the public key
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getInputData(dataToSignHash, addressPath) {
        const code = new bitcore_mnemonic_1.default(this.seed);
        const xpriv = code.toHDPrivateKey(this.passphrase, this.network.bitcoreNetwork);
        const derivedKey = xpriv.deriveNonCompliantChild(addressPath);
        const privateKey = derivedKey.privateKey;
        const sig = bitcore_lib_1.crypto.ECDSA.sign(dataToSignHash, privateKey, 'little').set({
            nhashtype: bitcore_lib_1.crypto.Signature.SIGHASH_ALL
        });
        const arr = [];
        helpers_1.default.pushDataToStack(arr, sig.toDER());
        helpers_1.default.pushDataToStack(arr, derivedKey.publicKey.toBuffer());
        return bitcore_lib_1.util.buffer.concat(arr);
    }
    /**
     * Return if wallet is ready to be used
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    isReady() {
        return this.state === walletState.READY;
    }
    /**
     * Update wallet state and emit 'state' event
     *
     * @param {string} state New wallet state
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    setState(state) {
        this.state = state;
        this.emit('state', state);
    }
    /**
     * Stop the wallet
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    stop() {
        this.walletId = null;
        this.state = walletState.NOT_STARTED;
    }
    /**
     * Get address at specific index
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getAddressAtIndex(index) {
        const code = new bitcore_mnemonic_1.default(this.seed);
        const xpriv = code.toHDPrivateKey(this.passphrase, this.network.bitcoreNetwork);
        const privkey = xpriv.deriveNonCompliantChild(`m/44'/${constants_1.HATHOR_BIP44_CODE}'/0'/0`);
        const key = privkey.deriveNonCompliantChild(index);
        const address = bitcore_lib_1.Address(key.publicKey, this.network.getNetwork());
        return address.toString();
    }
    /**
     * Get the current address to be used
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getCurrentAddress({ markAsUsed = false } = {}) {
        const newAddressesLen = this.newAddresses.length;
        if (this.indexToUse > newAddressesLen - 1) {
            const addressInfo = this.newAddresses[newAddressesLen - 1];
            return Object.assign(Object.assign({}, addressInfo), { info: 'GAP_LIMIT_REACHED' });
        }
        const addressInfo = this.newAddresses[this.indexToUse];
        if (markAsUsed) {
            this.indexToUse += 1;
        }
        return addressInfo;
    }
    /**
     * Get the next address after the current available
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getNextAddress() {
        // First we mark the current address as used, then return the next
        this.getCurrentAddress({ markAsUsed: true });
        return this.getCurrentAddress();
    }
    getAddressIndex(address) {
        throw new errors_1.WalletError('Not implemented.');
    }
    isAddressMine(address) {
        throw new errors_1.WalletError('Not implemented.');
    }
    getTx(id) {
        throw new errors_1.WalletError('Not implemented.');
    }
    getAddressInfo(address, options = {}) {
        throw new errors_1.WalletError('Not implemented.');
    }
    consolidateUtxos(destinationAddress, options = {}) {
        throw new errors_1.WalletError('Not implemented.');
    }
    getFullHistory() {
        throw new errors_1.WalletError('Not implemented.');
    }
    /**
     * Create SendTransaction object and run from mining
     * Returns a promise that resolves when the send succeeds
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    handleSendPreparedTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const sendTransaction = new sendTransactionWalletService_1.default(this, { transaction });
            return sendTransaction.runFromMining();
        });
    }
    /**
     * Prepare create new token data, sign the inputs and returns an object ready to be mined
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    prepareCreateNewToken(name, symbol, amount, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const newOptions = Object.assign({
                address: null,
                changeAddress: null,
                createMintAuthority: true,
                createMeltAuthority: true,
                nftData: null,
            }, options);
            const isNFT = newOptions.nftData !== null;
            // 1. Calculate HTR deposit needed
            let deposit = tokens_1.default.getDepositAmount(amount);
            if (isNFT) {
                // For NFT we have a fee of 0.01 HTR, then the deposit utxo query must get an additional 1
                deposit += 1;
            }
            // 2. Get utxos for HTR
            const { utxos, changeAmount } = yield this.getUtxos({ tokenId: constants_1.HATHOR_TOKEN_CONFIG.uid, totalAmount: deposit });
            if (utxos.length === 0) {
                throw new errors_1.UtxoError(`No utxos available to fill the request. Token: HTR - Amount: ${deposit}.`);
            }
            const utxosAddressPath = [];
            // 3. Create the transaction object with the inputs and outputs (new token amount, change address with HTR, mint/melt authorities - depending on parameters)
            const inputsObj = [];
            for (const utxo of utxos) {
                inputsObj.push(new input_1.default(utxo.txId, utxo.index));
                utxosAddressPath.push(utxo.addressPath);
            }
            // Create outputs
            const outputsObj = [];
            // NFT transactions must have the first output as the script data
            if (isNFT) {
                outputsObj.push(helpers_1.default.createNFTOutput(newOptions.nftData));
            }
            // a. Token amount
            const addressToUse = newOptions.address || this.getCurrentAddress({ markAsUsed: true }).address;
            const address = new address_1.default(addressToUse, { network: this.network });
            if (!address.isValid()) {
                throw new errors_1.SendTxError(`Address ${newOptions.address} is not valid.`);
            }
            const p2pkh = new p2pkh_1.default(address);
            const p2pkhScript = p2pkh.createScript();
            outputsObj.push(new output_1.default(amount, p2pkhScript, { tokenData: 1 }));
            if (newOptions.createMintAuthority) {
                // b. Mint authority
                outputsObj.push(new output_1.default(constants_1.TOKEN_MINT_MASK, p2pkhScript, { tokenData: constants_1.AUTHORITY_TOKEN_DATA }));
            }
            if (newOptions.createMeltAuthority) {
                // c. Melt authority
                outputsObj.push(new output_1.default(constants_1.TOKEN_MELT_MASK, p2pkhScript, { tokenData: constants_1.AUTHORITY_TOKEN_DATA }));
            }
            if (changeAmount) {
                // d. HTR change output
                const changeAddressStr = newOptions.changeAddress || this.getCurrentAddress({ markAsUsed: true }).address;
                const changeAddress = new address_1.default(changeAddressStr, { network: this.network });
                if (!changeAddress.isValid()) {
                    throw new errors_1.SendTxError(`Address ${newOptions.changeAddress} is not valid.`);
                }
                const p2pkhChange = new p2pkh_1.default(changeAddress);
                const p2pkhChangeScript = p2pkhChange.createScript();
                outputsObj.push(new output_1.default(changeAmount, p2pkhChangeScript));
            }
            const tx = new create_token_transaction_1.default(name, symbol, inputsObj, outputsObj);
            const dataToSignHash = tx.getDataToSignHash();
            for (const [idx, inputObj] of tx.inputs.entries()) {
                const inputData = this.getInputData(dataToSignHash, utxosAddressPath[idx]);
                inputObj.setData(inputData);
            }
            tx.prepareToSend();
            return tx;
        });
    }
    /**
     * Create a new custom token in the network
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    createNewToken(name, symbol, amount, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const tx = yield this.prepareCreateNewToken(name, symbol, amount, options);
            return this.handleSendPreparedTransaction(tx);
        });
    }
    /**
     * Prepare mint token data, sign the inputs and returns an object ready to be mined
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    prepareMintTokensData(token, amount, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const newOptions = Object.assign({
                address: null,
                changeAddress: null,
                createAnotherMint: true,
            }, options);
            // 1. Calculate HTR deposit needed
            const deposit = tokens_1.default.getDepositAmount(amount);
            // 2. Get utxos for HTR
            const { utxos, changeAmount } = yield this.getUtxos({ tokenId: constants_1.HATHOR_TOKEN_CONFIG.uid, totalAmount: deposit });
            if (utxos.length === 0) {
                throw new errors_1.UtxoError(`No utxos available to fill the request. Token: HTR - Amount: ${deposit}.`);
            }
            // 3. Get mint authority
            const ret = yield this.getUtxos({ tokenId: token, authority: constants_1.TOKEN_MINT_MASK });
            if (ret.utxos.length === 0) {
                throw new errors_1.UtxoError(`No authority utxo available for minting tokens. Token: ${token}.`);
            }
            // it's safe to assume that we have an utxo in the array
            const mintUtxo = ret.utxos[0];
            // 4. Create inputs from utxos
            const inputsObj = [];
            for (const utxo of utxos) {
                // First add HTR utxos
                inputsObj.push(new input_1.default(utxo.txId, utxo.index));
            }
            // Then add a single mint authority utxo
            inputsObj.push(new input_1.default(mintUtxo.txId, mintUtxo.index));
            // Create outputs
            const outputsObj = [];
            // a. Token amount
            const addressToUse = newOptions.address || this.getCurrentAddress({ markAsUsed: true }).address;
            const address = new address_1.default(addressToUse, { network: this.network });
            if (!address.isValid()) {
                throw new errors_1.SendTxError(`Address ${newOptions.address} is not valid.`);
            }
            const p2pkh = new p2pkh_1.default(address);
            const p2pkhScript = p2pkh.createScript();
            outputsObj.push(new output_1.default(amount, p2pkhScript, { tokenData: 1 }));
            if (newOptions.createAnotherMint) {
                // b. Mint authority
                outputsObj.push(new output_1.default(constants_1.TOKEN_MINT_MASK, p2pkhScript, { tokenData: constants_1.AUTHORITY_TOKEN_DATA }));
            }
            if (changeAmount) {
                // c. HTR change output
                const changeAddressStr = newOptions.changeAddress || this.getCurrentAddress({ markAsUsed: true }).address;
                const changeAddress = new address_1.default(changeAddressStr, { network: this.network });
                if (!changeAddress.isValid()) {
                    throw new errors_1.SendTxError(`Address ${newOptions.changeAddress} is not valid.`);
                }
                const p2pkhChange = new p2pkh_1.default(changeAddress);
                const p2pkhChangeScript = p2pkhChange.createScript();
                outputsObj.push(new output_1.default(changeAmount, p2pkhChangeScript));
            }
            const tx = new transaction_2.default(inputsObj, outputsObj);
            tx.tokens = [token];
            const dataToSignHash = tx.getDataToSignHash();
            for (const [idx, inputObj] of tx.inputs.entries()) {
                // We have an array of utxos and the last input is the one with the authority
                const addressPath = idx === tx.inputs.length - 1 ? mintUtxo.addressPath : utxos[idx].addressPath;
                const inputData = this.getInputData(dataToSignHash, addressPath);
                inputObj.setData(inputData);
            }
            tx.prepareToSend();
            return tx;
        });
    }
    /**
     * Mint new token units
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    mintTokens(token, amount, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const tx = yield this.prepareMintTokensData(token, amount, options);
            return this.handleSendPreparedTransaction(tx);
        });
    }
    /**
     * Prepare melt token data, sign the inputs and returns an object ready to be mined
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    prepareMeltTokensData(token, amount, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const newOptions = Object.assign({
                address: null,
                changeAddress: null,
                createAnotherMelt: true,
            }, options);
            // 1. Calculate HTR deposit needed
            const withdraw = tokens_1.default.getWithdrawAmount(amount);
            // 2. Get utxos for custom token to melt
            const { utxos, changeAmount } = yield this.getUtxos({ tokenId: token, totalAmount: amount });
            if (utxos.length === 0) {
                throw new errors_1.UtxoError(`Not enough tokens to be melted. Token: ${token} - Amount: ${amount}.`);
            }
            // 3. Get mint authority
            const ret = yield this.getUtxos({ tokenId: token, authority: constants_1.TOKEN_MELT_MASK });
            if (ret.utxos.length === 0) {
                throw new errors_1.UtxoError(`No authority utxo available for melting tokens. Token: ${token}.`);
            }
            // it's safe to assume that we have an utxo in the array
            const meltUtxo = ret.utxos[0];
            // 4. Create inputs from utxos
            const inputsObj = [];
            for (const utxo of utxos) {
                // First add HTR utxos
                inputsObj.push(new input_1.default(utxo.txId, utxo.index));
            }
            // Then add a single mint authority utxo (it's safe to assume that we have an utxo in the array)
            inputsObj.push(new input_1.default(meltUtxo.txId, meltUtxo.index));
            // Create outputs
            const outputsObj = [];
            // a. Deposit back
            const addressToUse = newOptions.address || this.getCurrentAddress({ markAsUsed: true }).address;
            const address = new address_1.default(addressToUse, { network: this.network });
            if (!address.isValid()) {
                throw new errors_1.SendTxError(`Address ${newOptions.address} is not valid.`);
            }
            const p2pkh = new p2pkh_1.default(address);
            const p2pkhScript = p2pkh.createScript();
            if (withdraw) {
                // We may have nothing to get back
                outputsObj.push(new output_1.default(withdraw, p2pkhScript, { tokenData: 0 }));
            }
            if (newOptions.createAnotherMelt) {
                // b. Mint authority
                outputsObj.push(new output_1.default(constants_1.TOKEN_MELT_MASK, p2pkhScript, { tokenData: constants_1.AUTHORITY_TOKEN_DATA }));
            }
            if (changeAmount) {
                // c. Token change output
                const changeAddressStr = newOptions.changeAddress || this.getCurrentAddress({ markAsUsed: true }).address;
                const changeAddress = new address_1.default(changeAddressStr, { network: this.network });
                if (!changeAddress.isValid()) {
                    throw new errors_1.SendTxError(`Address ${newOptions.changeAddress} is not valid.`);
                }
                const p2pkhChange = new p2pkh_1.default(changeAddress);
                const p2pkhChangeScript = p2pkhChange.createScript();
                outputsObj.push(new output_1.default(changeAmount, p2pkhChangeScript, { tokenData: 1 }));
            }
            const tx = new transaction_2.default(inputsObj, outputsObj);
            tx.tokens = [token];
            const dataToSignHash = tx.getDataToSignHash();
            for (const [idx, inputObj] of tx.inputs.entries()) {
                // We have an array of utxos and the last input is the one with the authority
                const addressPath = idx === tx.inputs.length - 1 ? meltUtxo.addressPath : utxos[idx].addressPath;
                const inputData = this.getInputData(dataToSignHash, addressPath);
                inputObj.setData(inputData);
            }
            tx.prepareToSend();
            return tx;
        });
    }
    /**
     * Melt custom token units
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    meltTokens(token, amount, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const tx = yield this.prepareMeltTokensData(token, amount, options);
            return this.handleSendPreparedTransaction(tx);
        });
    }
    /**
     * Prepare delegate authority data, sign the inputs and returns an object ready to be mined
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    prepareDelegateAuthorityData(token, type, address, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const newOptions = Object.assign({
                anotherAuthorityAddress: null,
                createAnotherAuthority: true,
            }, options);
            let authority, mask;
            if (type === 'mint') {
                authority = 1;
                mask = constants_1.TOKEN_MINT_MASK;
            }
            else if (type === 'melt') {
                authority = 2;
                mask = constants_1.TOKEN_MELT_MASK;
            }
            else {
                throw new errors_1.WalletError('Type options are mint and melt for delegate authority method.');
            }
            // 1. Get authority utxo to spend
            const ret = yield this.getUtxos({ tokenId: token, authority });
            if (ret.utxos.length === 0) {
                throw new errors_1.UtxoError(`No authority utxo available for delegating authority. Token: ${token} - Type ${type}.`);
            }
            // it's safe to assume that we have an utxo in the array
            const utxo = ret.utxos[0];
            // 2. Create input from utxo
            const inputsObj = [];
            inputsObj.push(new input_1.default(utxo.txId, utxo.index));
            // Create outputs
            const outputsObj = [];
            const addressObj = new address_1.default(address, { network: this.network });
            if (!addressObj.isValid()) {
                throw new errors_1.SendTxError(`Address ${address} is not valid.`);
            }
            const p2pkh = new p2pkh_1.default(addressObj);
            const p2pkhScript = p2pkh.createScript();
            outputsObj.push(new output_1.default(mask, p2pkhScript, { tokenData: constants_1.AUTHORITY_TOKEN_DATA }));
            if (newOptions.createAnotherAuthority) {
                const anotherAddressStr = newOptions.anotherAuthorityAddress || this.getCurrentAddress({ markAsUsed: true }).address;
                const anotherAddress = new address_1.default(anotherAddressStr, { network: this.network });
                if (!anotherAddress.isValid()) {
                    throw new errors_1.SendTxError(`Address ${newOptions.anotherAuthorityAddress} is not valid.`);
                }
                const p2pkhAnotherAddress = new p2pkh_1.default(anotherAddress);
                const p2pkhAnotherAddressScript = p2pkhAnotherAddress.createScript();
                outputsObj.push(new output_1.default(mask, p2pkhAnotherAddressScript, { tokenData: constants_1.AUTHORITY_TOKEN_DATA }));
            }
            const tx = new transaction_2.default(inputsObj, outputsObj);
            tx.tokens = [token];
            // Set input data
            const dataToSignHash = tx.getDataToSignHash();
            const inputData = this.getInputData(dataToSignHash, utxo.addressPath);
            inputsObj[0].setData(inputData);
            tx.prepareToSend();
            return tx;
        });
    }
    /**
     * Transfer (delegate) authority outputs to another address
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    delegateAuthority(token, type, address, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const tx = yield this.prepareDelegateAuthorityData(token, type, address, options);
            return this.handleSendPreparedTransaction(tx);
        });
    }
    /**
     * Destroy authority outputs
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    prepareDestroyAuthorityData(token, type, count) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            let authority, mask;
            if (type === 'mint') {
                authority = 1;
                mask = constants_1.TOKEN_MINT_MASK;
            }
            else if (type === 'melt') {
                authority = 2;
                mask = constants_1.TOKEN_MELT_MASK;
            }
            else {
                throw new errors_1.WalletError('Type options are mint and melt for destroy authority method.');
            }
            // 1. Get authority utxo to spend
            const ret = yield this.getUtxos({ tokenId: token, authority, count });
            if (ret.utxos.length < count) {
                throw new errors_1.UtxoError(`Not enough authority utxos available for destroying. Token: ${token} - Type ${type}. Requested quantity ${count} - Available quantity ${ret.utxos.length}`);
            }
            // 1. Create input from utxo
            const inputsObj = [];
            for (const utxo of ret.utxos) {
                inputsObj.push(new input_1.default(utxo.txId, utxo.index));
            }
            // No outputs because we are just destroying the authority utxos
            const tx = new transaction_2.default(inputsObj, []);
            tx.tokens = [token];
            // Set input data
            const dataToSignHash = tx.getDataToSignHash();
            for (const [idx, inputObj] of tx.inputs.entries()) {
                const inputData = this.getInputData(dataToSignHash, ret.utxos[idx].addressPath);
                inputObj.setData(inputData);
            }
            tx.prepareToSend();
            return tx;
        });
    }
    /**
     * Destroy authority outputs
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    destroyAuthority(token, type, count) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const tx = yield this.prepareDestroyAuthorityData(token, type, count);
            return this.handleSendPreparedTransaction(tx);
        });
    }
    /**
     * Create an NFT in the network
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    createNFT(name, symbol, amount, data, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const newOptions = Object.assign({
                address: null,
                changeAddress: null,
                createMintAuthority: false,
                createMeltAuthority: false,
            }, options);
            newOptions['nftData'] = data;
            const tx = yield this.prepareCreateNewToken(name, symbol, amount, newOptions);
            return this.handleSendPreparedTransaction(tx);
        });
    }
}
exports.default = HathorWalletServiceWallet;
//# sourceMappingURL=wallet.js.map