"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPushData = exports.parseScriptData = exports.parseP2PKH = void 0;
const p2pkh_1 = __importDefault(require("../models/p2pkh"));
const script_data_1 = __importDefault(require("../models/script_data"));
const helpers_1 = __importDefault(require("../utils/helpers"));
const buffer_1 = require("../utils/buffer");
const lodash_1 = __importDefault(require("lodash"));
const errors_1 = require("../errors");
const opcodes_1 = require("../opcodes");
/**
* Parse P2PKH output script
*
* @param {Buffer} buff Output script
* @param {Network} network Network to get the address first byte parameter
*
* @return {P2PKH} P2PKH object
*/
exports.parseP2PKH = (buff, network) => {
    let timelock = null;
    let offset = 0;
    // We should clone the buffer being sent in order to never mutate
    // what comes from outside the library
    let scriptBuf = lodash_1.default.clone(buff);
    if (scriptBuf.length === 31) {
        // There is timelock in this script
        // First byte is len, which is always 4 bytes
        [timelock, scriptBuf] = buffer_1.unpackToInt(4, false, scriptBuf.slice(1));
        offset = 1;
    }
    else {
        if (scriptBuf.length !== 25) {
            // It's not a P2PKH
            throw new errors_1.ParseScriptError('Invalid output script.');
        }
    }
    let addressHash;
    [addressHash, scriptBuf] = buffer_1.unpackLen(20, scriptBuf.slice(3 + offset));
    return new p2pkh_1.default(helpers_1.default.encodeAddress(addressHash, network), { timelock });
};
/**
* Parse Data output script
*
* @param {Buffer} buff Output script
*
* @return {ScriptData} ScriptData object
*/
exports.parseScriptData = (buff) => {
    // We should clone the buffer being sent in order to never mutate
    // what comes from outside the library
    let scriptBuf = lodash_1.default.clone(buff);
    if (scriptBuf.length < 2) {
        // At least 1 byte for len data and 1 byte for OP_CHECKSIG
        throw new errors_1.ParseScriptError('Invalid output script. Script must have at least 2 bytes.');
    }
    // The expected len will be at least 2 bytes
    // 1 for the script len and 1 for the OP_CHECKSIG in the end
    let expectedLen = 2;
    let dataBytesLen;
    // If we have OP_PUSHDATA1 as first byte, the second byte has the length of data
    // otherwise, the first byte already has the length of data
    if (scriptBuf[0] === opcodes_1.OP_PUSHDATA1[0]) {
        expectedLen += 1;
        dataBytesLen = scriptBuf[1];
    }
    else {
        dataBytesLen = scriptBuf[0];
    }
    // Set the expected length
    expectedLen += dataBytesLen;
    if (expectedLen !== scriptBuf.length) {
        // The script has different qty of bytes than expected
        throw new errors_1.ParseScriptError(`Invalid output script. Expected len ${expectedLen} and received len ${scriptBuf.length}.`);
    }
    if (scriptBuf[expectedLen - 1] !== opcodes_1.OP_CHECKSIG[0]) {
        // Last byte must be an OP_CHECKSIG
        throw new errors_1.ParseScriptError('Invalid output script. Last byte must be OP_CHECKSIG.');
    }
    // Get data from the script
    const data = exports.getPushData(scriptBuf);
    let decodedData;
    try {
        decodedData = data.toString('utf-8');
    }
    catch (e) {
        throw new errors_1.ParseScriptError('Invalid output script. Error decoding data to utf-8.');
    }
    return new script_data_1.default(decodedData);
};
/**
* Parse buffer to data decoding pushdata opcodes
*
* @param {Buffer} buff Buffer to get pushdata
*
* @return {Buffer} Data extracted from buffer
*/
exports.getPushData = (buff) => {
    // We should clone the buffer being sent in order to never mutate
    // what comes from outside the library
    let scriptBuf = lodash_1.default.clone(buff);
    if (scriptBuf.length === 0) {
        throw new errors_1.ParseError('Invalid buffer.');
    }
    let lenData, start;
    if (scriptBuf[0] > 75) {
        lenData = scriptBuf[1];
        start = 2;
    }
    else {
        lenData = scriptBuf[0];
        start = 1;
    }
    return scriptBuf.slice(start, start + lenData);
};
//# sourceMappingURL=scripts.js.map