"use strict";
/**
 * Copyright (c) Hathor Labs and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const opcodes_1 = require("../opcodes");
const constants_1 = require("../constants");
const buffer_1 = __importDefault(require("buffer"));
const long_1 = __importDefault(require("long"));
const transaction_1 = __importDefault(require("../models/transaction"));
const p2pkh_1 = __importDefault(require("../models/p2pkh"));
const script_data_1 = __importDefault(require("../models/script_data"));
const create_token_transaction_1 = __importDefault(require("../models/create_token_transaction"));
const input_1 = __importDefault(require("../models/input"));
const output_1 = __importDefault(require("../models/output"));
const address_1 = __importDefault(require("../models/address"));
const buffer_2 = require("../utils/buffer");
const bitcore_lib_1 = require("bitcore-lib");
const lodash_1 = require("lodash");
const errors_1 = require("../errors");
const errorMessages_1 = require("../errorMessages");
/**
 * Helper methods
 *
 * @namespace Helpers
 */
const helpers = {
    /**
     * Round float to closest int
     *
     * @param {number} n Number to be rounded
     *
     * @return {number} Closest integer to n passed
     *
     * @memberof Helpers
     * @inner
     */
    roundFloat(n) {
        return Math.round(n * 100) / 100;
    },
    /**
     * Get the formatted value with decimal places and thousand separators
     *
     * @param {number} value Amount to be formatted
     *
     * @return {string} Formatted value
     *
     * @memberof Helpers
     * @inner
     */
    prettyValue(value) {
        const fixedPlaces = (value / Math.pow(10, constants_1.DECIMAL_PLACES)).toFixed(constants_1.DECIMAL_PLACES);
        const integerPart = fixedPlaces.split('.')[0];
        const decimalPart = fixedPlaces.split('.')[1];
        return `${this.prettyIntegerValue(parseInt(integerPart))}.${decimalPart}`;
    },
    /**
     * Get the formatted value for an integer number
     *
     * @param {number} value Amount to be formatted
     *
     * @return {string} Formatted value
     *
     * @memberof Helpers
     * @inner
     */
    prettyIntegerValue(value) {
        const integerFormated = new Intl.NumberFormat('en-US').format(Math.abs(value));
        const signal = value < 0 ? '-' : '';
        return `${signal}${integerFormated}`;
    },
    /**
     * Validate if the passed version is valid, comparing with the minVersion
     *
     * @param {string} version Version to check if is valid
     * @param {string} minVersion Minimum allowed version
     *
     * @return {boolean}
     *
     * @memberof Helpers
     * @inner
     */
    isVersionAllowed(version, minVersion) {
        // Verifies if the version in parameter is allowed to make requests to other min version
        if (version.includes('beta') !== minVersion.includes('beta')) {
            // If one version is beta and the other is not, it's not allowed to use it
            return false;
        }
        // Clean the version string to have an array of integers
        // Check for each value if the version is allowed
        let versionTestArr = this.getCleanVersionArray(version);
        let minVersionArr = this.getCleanVersionArray(minVersion);
        for (let i = 0; i < minVersionArr.length; i++) {
            if (minVersionArr[i] > versionTestArr[i]) {
                return false;
            }
            else if (minVersionArr[i] < versionTestArr[i]) {
                return true;
            }
        }
        return true;
    },
    /**
     * Get the version numbers separated by dot
     * For example: if you haver version 0.3.1-beta you will get ['0', '3', '1']
     *
     * @param {string} version
     *
     * @return {Array} Array of numbers with each version number
     *
     * @memberof Helpers
     * @inner
     */
    getCleanVersionArray(version) {
        return version.replace(/[^\d.]/g, '').split('.');
    },
    /**
     * Transform int to bytes
     *
     * @param {number} value Integer to be transformed to bytes
     * @param {number} bytes How many bytes this number uses
     *
     * @return {Buffer} number in bytes
     * @memberof Helpers
     * @inner
     */
    intToBytes(value, bytes) {
        let arr = new ArrayBuffer(bytes);
        let view = new DataView(arr);
        if (bytes === 1) {
            // byteOffset = 0;
            view.setUint8(0, value);
        }
        else if (bytes === 2) {
            // byteOffset = 0; isLittleEndian = false
            view.setUint16(0, value, false);
        }
        else if (bytes === 4) {
            // byteOffset = 0; isLittleEndian = false
            view.setUint32(0, value, false);
        }
        return buffer_1.default.Buffer.from(arr);
    },
    /**
     * Transform signed int to bytes (1, 2, or 4 bytes)
     *
     * @param {number} value Integer to be transformed to bytes
     * @param {number} bytes How many bytes this number uses
     *
     * @return {Buffer} number in bytes
     * @memberof Helpers
     * @inner
     */
    signedIntToBytes(value, bytes) {
        let arr = new ArrayBuffer(bytes);
        let view = new DataView(arr);
        if (bytes === 1) {
            // byteOffset = 0
            view.setInt8(0, value);
        }
        else if (bytes === 2) {
            // byteOffset = 0; isLittleEndian = false
            view.setInt16(0, value, false);
        }
        else if (bytes === 4) {
            view.setInt32(0, value, false);
        }
        else if (bytes === 8) {
            // In case of 8 bytes I need to handle the int with a Long lib
            let long = long_1.default.fromNumber(value, false);
            arr = long.toBytesBE();
        }
        return buffer_1.default.Buffer.from(arr);
    },
    /**
     * Transform float to bytes
     *
     * @param {number} value Integer to be transformed to bytes
     * @param {number} bytes How many bytes this number uses
     *
     * @return {Buffer} number in bytes
     * @memberof Helpers
     * @inner
     */
    floatToBytes(value, bytes) {
        let arr = new ArrayBuffer(bytes);
        let view = new DataView(arr);
        if (bytes === 8) {
            // byteOffset = 0; isLitteEndian = false
            view.setFloat64(0, value, false);
        }
        return buffer_1.default.Buffer.from(arr);
    },
    /**
     * Push data to the stack checking if need to add the OP_PUSHDATA1 opcode
     * We push the length of data and the data
     * In case the data has length > 75, we need to push the OP_PUSHDATA1 before the length
     * We always push bytes
     *
     * We update the array of Buffer sent as parameter, so we don't return a new one
     *
     * @param {Array} stack Stack of bytes from the script
     * @param {Buffer} data Data to be pushed to stack
     *
     * @memberof Helpers
     * @inner
     */
    pushDataToStack(stack, data) {
        // In case data has length bigger than 75, we need to add a pushdata opcode
        if (data.length > 75) {
            stack.push(opcodes_1.OP_PUSHDATA1);
        }
        stack.push(this.intToBytes(data.length, 1));
        stack.push(data);
    },
    /**
     * Return the checksum of the bytes passed
     * Checksum is calculated as the 4 first bytes of the double sha256
     *
     * @param {Buffer} bytes Data from where the checksum is calculated
     *
     * @return {Buffer}
     * @memberof Helpers
     * @inner
     */
    getChecksum(bytes) {
        return bitcore_lib_1.crypto.Hash.sha256sha256(bytes).slice(0, 4);
    },
    /**
     * Get encoded address object from address hash (20 bytes) and network
     * We complete the address bytes with the network byte and checksum
     * then we encode to base 58 and create the address object
     *
     * @param {Buffer} addressHash 20 bytes of the address hash in the output script
     * @param {Network} network Network to get the address first byte parameter
     *
     * @return {Address}
     * @memberof Helpers
     * @inner
     */
    encodeAddress(addressHash, network) {
        if (addressHash.length !== 20) {
            throw new Error('Expect address hash that must have 20 bytes.');
        }
        const addressVersionBytes = buffer_1.default.Buffer.from([network.versionBytes.p2pkh]);
        // With this sliced address we can calculate the checksum
        const slicedAddress = buffer_1.default.Buffer.concat([addressVersionBytes, addressHash]);
        const checksum = this.getChecksum(slicedAddress);
        const addressBytes = buffer_1.default.Buffer.concat([slicedAddress, checksum]);
        return new address_1.default(bitcore_lib_1.encoding.Base58.encode(addressBytes), { network });
    },
    /**
     * Create a transaction from bytes
     * First we get the version value from the bytes to discover the
     * transaction type. We currently support only regular transactions and
     * create token transactions.
     *
     * @param {Buffer} bytes Transaction in bytes
     * @param {Network} network Network to get the address first byte parameter
     *
     * @throws ParseError if sequence of bytes is invalid or network is undefined/null
     *
     * @return {Transaction | CreateTokenTransaction}
     * @memberof Helpers
     * @inner
     */
    createTxFromBytes(bytes, network) {
        if (!network) {
            throw new errors_1.ParseError('Invalid network parameter.');
        }
        // We should clone the buffer being sent in order to never mutate
        // what comes from outside the library
        // as soon as it's available natively we should use an immutable buffer
        const cloneBuffer = lodash_1.clone(bytes);
        // Get version
        const [version,] = buffer_2.unpackToInt(2, false, cloneBuffer);
        if (version === constants_1.DEFAULT_TX_VERSION) {
            return transaction_1.default.createFromBytes(cloneBuffer, network);
        }
        else if (version === constants_1.CREATE_TOKEN_TX_VERSION) {
            return create_token_transaction_1.default.createFromBytes(cloneBuffer, network);
        }
        else {
            throw new errors_1.ParseError('We currently support only the Transaction and CreateTokenTransaction types. Other types will be supported in the future.');
        }
    },
    /**
     * Create a transaction from hex
     * We transform the hex in bytes and call the function to get transaction from bytes
     *
     * @param {string} hex Transaction in hexadecimal
     * @param {Network} network Network to get the address first byte parameter
     *
     * @return {Transaction | CreateTokenTransaction}
     * @memberof Helpers
     * @inner
     */
    createTxFromHex(hex, network) {
        return this.createTxFromBytes(buffer_2.hexToBuffer(hex), network);
    },
    /**
     * Asyncronous sleep
     * Creates a promise that will be resolved after sleep time
     *
     * @param {number} milliseconds Sleep time in milliseconds
     *
     * @return {Promise}
     * @memberof Helpers
     * @inner
     */
    sleep(milliseconds) {
        return __awaiter(this, void 0, void 0, function* () {
            const promise = new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve();
                }, milliseconds);
            });
            return promise;
        });
    },
    /**
     * Create a transaction from object data
     * We used to work only with data object to handle transactions in the past inside the lib
     * This method was created to transform those objects into Transaction class instances
     *
     * @param {Object} 'data': {'version', 'weight', 'timestamp', 'tokens', 'inputs': [{'tx_id', 'index'}], 'outputs': [{'address', 'value', 'tokenData', 'timelock'}]}
     *
     * if it's a create token transaction, then it expects 'name' and 'symbol' as well.
     *
     * @param {Network} network Network to get the address first byte parameter
     *
     * @throws {AddressError} If the address used in the P2PKH outputs is invalid
     *
     * @memberof Helpers
     * @inner
     */
    createTxFromData(data, network) {
        const inputs = [];
        for (const input of data.inputs) {
            const inputObj = new input_1.default(input.tx_id, input.index, {
                data: input.data
            });
            inputs.push(inputObj);
        }
        const outputs = [];
        for (const output of data.outputs) {
            let outputObj;
            if (output.type === 'data') {
                // Is NFT output
                outputObj = this.createNFTOutput(output.data);
            }
            else if (output.type === 'p2pkh' || output.type === undefined) {
                // P2PKH
                // for compatibility reasons we will accept an output without type as p2pkh as fallback
                const address = new address_1.default(output.address, { network });
                // This will throw AddressError in case the adress is invalid
                address.validateAddress();
                const p2pkh = new p2pkh_1.default(address, { timelock: output.timelock || null });
                const p2pkhScript = p2pkh.createScript();
                outputObj = new output_1.default(output.value, p2pkhScript, { tokenData: output.tokenData });
            }
            else {
                throw new Error('Invalid output type.');
            }
            outputs.push(outputObj);
        }
        const options = {
            version: data.version,
            weight: data.weight,
            timestamp: data.timestamp,
            tokens: data.tokens
        };
        if (data.version === constants_1.CREATE_TOKEN_TX_VERSION) {
            return new create_token_transaction_1.default(data.name, data.symbol, inputs, outputs, options);
        }
        else if (data.version === constants_1.DEFAULT_TX_VERSION) {
            return new transaction_1.default(inputs, outputs, options);
        }
        else {
            throw new errors_1.ParseError(errorMessages_1.ErrorMessages.UNSUPPORTED_TX_TYPE);
        }
    },
    /**
     * Create NFT output from data string
     *
     * @memberof Helpers
     * @inner
     */
    createNFTOutput(data) {
        const scriptData = new script_data_1.default(data);
        // Value 1 and token HTR
        return new output_1.default(1, scriptData.createScript());
    },
};
exports.default = helpers;
//# sourceMappingURL=helpers.js.map